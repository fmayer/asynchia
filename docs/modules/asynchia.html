

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>asynchia &mdash; asynchia v0.1.0a documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.0a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="asynchia v0.1.0a documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="index.html" />
    <link rel="next" title="asynchia.dsl" href="asynchia.dsl.html" />
    <link rel="prev" title="API Documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="asynchia.dsl.html" title="asynchia.dsl"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="API Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">asynchia v0.1.0a documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-asynchia">
<span id="asynchia"></span><h1>asynchia<a class="headerlink" href="#module-asynchia" title="Permalink to this headline">¶</a></h1>
<p>asynchia is a minimalist asynchronous networking library.</p>
<dl class="class">
<dt id="asynchia.AcceptHandler">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">AcceptHandler</tt><big>(</big><em>transport=None</em><big>)</big><a class="headerlink" href="#asynchia.AcceptHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle socket that accepts connections.</p>
<dl class="method">
<dt id="asynchia.AcceptHandler.handle_accept">
<tt class="descname">handle_accept</tt><big>(</big><em>sock</em>, <em>addr</em><big>)</big><a class="headerlink" href="#asynchia.AcceptHandler.handle_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Accept connection from addr at sock.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.AcceptHandler.handle_read">
<tt class="descname">handle_read</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.AcceptHandler.handle_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not override.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.Handler">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">Handler</tt><big>(</big><em>transport</em><big>)</big><a class="headerlink" href="#asynchia.Handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a socket object. Call this objects handle_* methods upon I/O</p>
<dl class="method">
<dt id="asynchia.Handler.handle_cleanup">
<tt class="descname">handle_cleanup</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever the Handler is voided, for whatever reason.
This may be the shutdown of the program, the closing of the
connection by the local end or the like.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_close">
<tt class="descname">handle_close</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection closed. Note that this is only called if the
connection is closed by the remote end!</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_connect">
<tt class="descname">handle_connect</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection established.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_connect_failed">
<tt class="descname">handle_connect_failed</tt><big>(</big><em>err</em><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_connect_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection couldn&#8217;t be established.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_error">
<tt class="descname">handle_error</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle error in handler.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_except">
<tt class="descname">handle_except</tt><big>(</big><em>err</em><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_except" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle exception state at error.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_read">
<tt class="descname">handle_read</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle read I/O at socket.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Handler.handle_write">
<tt class="descname">handle_write</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Handler.handle_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle write I/O at socket.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.Notifier">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">Notifier</tt><a class="headerlink" href="#asynchia.Notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Call handle functions of the object with error handling.</p>
<dl class="staticmethod">
<dt id="asynchia.Notifier.cleanup_obj">
<em class="property">static </em><tt class="descname">cleanup_obj</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.Notifier.cleanup_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Call handle_cleanup of the object. If any error occurs within it,
call handle_error of the object.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="asynchia.Notifier.close_obj">
<em class="property">static </em><tt class="descname">close_obj</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.Notifier.close_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Call handle_close of the object. If any error occurs within it,
call handle_error of the object.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="asynchia.Notifier.except_obj">
<em class="property">static </em><tt class="descname">except_obj</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.Notifier.except_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Call handle_except of the object. If any error occurs within it,
call handle_error of the object.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="asynchia.Notifier.read_obj">
<em class="property">static </em><tt class="descname">read_obj</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.Notifier.read_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Call handle_read of the object. If any error occurs within it,
call handle_error of the object. If it is the first read event call
the handle_connect method.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="asynchia.Notifier.write_obj">
<em class="property">static </em><tt class="descname">write_obj</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.Notifier.write_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Call handle_write of the object. If any error occurs within it,
call handle_error of the object. If it is the first write event call
the handle_connect method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.SendallTrait">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">SendallTrait</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#asynchia.SendallTrait" title="Permalink to this definition">¶</a></dt>
<dd><p>Enhance Transport with sendall that buffers data and sends it all,
if necessary in multiple steps. Mix into the transport to use.</p>
<blockquote>
<dl class="docutils">
<dt>class SendAllTransport(asynchia.SendallTrait, asynchia.SocketTransport):</dt>
<dd>pass</dd>
</dl>
</blockquote>
<dl class="method">
<dt id="asynchia.SendallTrait.get_writeable">
<tt class="descname">get_writeable</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SendallTrait.get_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Necessary for the property.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SendallTrait.handle_write">
<tt class="descname">handle_write</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SendallTrait.handle_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SendallTrait.sendall">
<tt class="descname">sendall</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#asynchia.SendallTrait.sendall" title="Permalink to this definition">¶</a></dt>
<dd><p>Send all of data, if necessary in multiple steps.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SendallTrait.set_writeable">
<tt class="descname">set_writeable</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#asynchia.SendallTrait.set_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>If sendall is active, save the value passed and set it to that
after sendall is finished.</p>
</dd></dl>

<dl class="attribute">
<dt id="asynchia.SendallTrait.writeable">
<tt class="descname">writeable</tt><a class="headerlink" href="#asynchia.SendallTrait.writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Necessary for the property.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.Server">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">Server</tt><big>(</big><em>transport</em>, <em>handlercls=&lt;class 'asynchia.Handler'&gt;</em><big>)</big><a class="headerlink" href="#asynchia.Server" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically create an instance of handlercls for every
connection.</p>
<dl class="method">
<dt id="asynchia.Server.handle_accept">
<tt class="descname">handle_accept</tt><big>(</big><em>sock</em>, <em>addr</em><big>)</big><a class="headerlink" href="#asynchia.Server.handle_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate the handler class.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Server.new_connection">
<tt class="descname">new_connection</tt><big>(</big><em>handler</em>, <em>addr</em><big>)</big><a class="headerlink" href="#asynchia.Server.new_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a new handler has been created.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Server.serve_forever">
<tt class="descname">serve_forever</tt><big>(</big><em>addr</em>, <em>num</em><big>)</big><a class="headerlink" href="#asynchia.Server.serve_forever" title="Permalink to this definition">¶</a></dt>
<dd><p>Serve a maximum of num connections at a time at addr.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.SocketMap">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">SocketMap</tt><big>(</big><em>notifier=None</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which sockets have I/O to be done and tell the notifier
to call the appropriate methods of their Handle objects.</p>
<dl class="method">
<dt id="asynchia.SocketMap.add_reader">
<tt class="descname">add_reader</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.add_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Add handler as a reader.
This indicates he wishes to read data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.add_transport">
<tt class="descname">add_transport</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.add_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Add handler to the socket-map. This gives the SocketMap
the responsibility to call its handle_read, handle_write,
handle_close and handle_connect upon new I/O events.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.add_writer">
<tt class="descname">add_writer</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.add_writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add handler as a writer.
This indicates he wishes to send data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketMap.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the handle_cleanup methods of all handlers contained
in the socket-map, indicating that they are void.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.del_reader">
<tt class="descname">del_reader</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.del_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete handler as a reader.
This indicates he no longer wants to read data until added again</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.del_transport">
<tt class="descname">del_transport</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.del_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove handler from the socket-map. It will no longer have its
handle_read, handle_write, handle_close and handle_connect methods
called upon new I/O events.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.del_writer">
<tt class="descname">del_writer</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.del_writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete handler as a writer.
This indicates he no longer wants to send data until added again</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.end_interrupt">
<tt class="descname">end_interrupt</tt><big>(</big><em>changeflags=False</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.end_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the socket-map.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.interrupt">
<tt class="descname">interrupt</tt><big>(</big><em>changeflags=False</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a context-manager that automatically resumes the
socket-map when the block is left.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketMap.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Periodically poll for I/O.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketMap.start_interrupt">
<tt class="descname">start_interrupt</tt><big>(</big><em>changeflags=False</em><big>)</big><a class="headerlink" href="#asynchia.SocketMap.start_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the socket-map until end_interrupt is called.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.SocketTransport">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">SocketTransport</tt><big>(</big><em>socket_map</em>, <em>sock=None</em>, <em>handler=None</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>A transport that uses a socket to send and receive data.</p>
<dl class="method">
<dt id="asynchia.SocketTransport.accept">
<tt class="descname">accept</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Accept incoming connection. Return (conn, addr). If either of
them is None, no connection could be accepted.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.await_connect">
<tt class="descname">await_connect</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.await_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Add handler to its socket-map&#8217;s writers if necessary.</p>
<p>At the next write-event from the socket-map handle_connect will
be called.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.bind">
<tt class="descname">bind</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind to address.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the socket.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.connect">
<tt class="descname">connect</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to (host, port).</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.fileno">
<tt class="descname">fileno</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fileno of underlying socket object.
Needed for select.select.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.get_readable">
<tt class="descname">get_readable</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.get_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether handler wants to read data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.get_writeable">
<tt class="descname">get_writeable</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.get_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether handler wants to write data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.listen">
<tt class="descname">listen</tt><big>(</big><em>num</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Listen for a maximum of num connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="asynchia.SocketTransport.readable">
<tt class="descname">readable</tt><a class="headerlink" href="#asynchia.SocketTransport.readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether handler wants to read data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.recv">
<tt class="descname">recv</tt><big>(</big><em>buffer_size</em>, <em>flags=0</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.recv" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive at most buffer_size bytes of data.</p>
<p>flags may be constructed by ORing zero or more of the following values:
MSG_PEEK</p>
<blockquote>
Peeks at an incoming message.
The data is treated as unread and the next recv() or similar
function shall still return this data.</blockquote>
<dl class="docutils">
<dt>MSG_OOB</dt>
<dd>Requests out-of-band data.
The significance and semantics of out-of-band data
are protocol-specific.</dd>
<dt>MSG_WAITALL</dt>
<dd>On SOCK_STREAM sockets this requests that the function block
until the full amount of data can be returned.
The function may return the smaller amount of data if the
socket is a message-based socket, if a signal is caught,
if the connection is terminated, if MSG_PEEK was specified,
or if an error is pending for the socket.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.reuse_addr">
<tt class="descname">reuse_addr</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.reuse_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Reuse the address.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.send">
<tt class="descname">send</tt><big>(</big><em>data</em>, <em>flags=0</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send data.</p>
<p>flags is constructed by ORing zero or more of the following values.</p>
<dl class="docutils">
<dt>MSG_OOB</dt>
<dd>Sends out-of-band data on sockets that support this notion
(e.g. SOCK_STREAM); the underlying protocol must also support
out-of-band data.</dd>
<dt>MSG_DONTROUTE</dt>
<dd>Don&#8217;t use a gateway to send out the packet, only send to hosts on
directly connected networks. This is usually used only by diagnostic
or routing programs. This is only defined for protocol families that
route; packet sockets don&#8217;t.</dd>
<dt>MSG_DONTWAIT</dt>
<dd>Enables non-blocking operation; if the operation would block,
EAGAIN is returned.</dd>
<dt>MSG_NOSIGNAL</dt>
<dd>Requests not to send SIGPIPE on errors on stream oriented sockets
when the other end breaks the connection. The EPIPE error is still
returned.</dd>
<dt>MSG_CONFIRM</dt>
<dd>(Linux 2.3+ only) Tell the link layer that forward process happened:
you got a successful reply from the other side. If the link layer
doesn&#8217;t get this it&#8217;ll regularly reprobe the neighbour
(e.g. via a unicast ARP). Only valid on SOCK_DGRAM and SOCK_RAW
sockets and currently only implemented for IPv4 and IPv6.
See arp(7) for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.set_readable">
<tt class="descname">set_readable</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.set_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether handler wants to read data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.set_socket">
<tt class="descname">set_socket</tt><big>(</big><em>sock</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.set_socket" title="Permalink to this definition">¶</a></dt>
<dd><p>Set socket as the socket of the handler.
If the socket is already connected do not call handle_connect
anymore.</p>
<p>The socket is automatically put into non-blocking mode.</p>
<p>If the Handler already had a socket, remove it out of the SocketMap
and add it with its new socket.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.set_writeable">
<tt class="descname">set_writeable</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.set_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether handler wants to write data.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.SocketTransport.stop_awaiting_connect">
<tt class="descname">stop_awaiting_connect</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.SocketTransport.stop_awaiting_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove handler from its socket-map&#8217;s writers if necessary.</p>
<p>At the next write-event from the socket-map handle_connect will
not be called.</p>
</dd></dl>

<dl class="attribute">
<dt id="asynchia.SocketTransport.writeable">
<tt class="descname">writeable</tt><a class="headerlink" href="#asynchia.SocketTransport.writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether handler wants to write data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asynchia.Transport">
<em class="property">class </em><tt class="descclassname">asynchia.</tt><tt class="descname">Transport</tt><big>(</big><em>handler=None</em><big>)</big><a class="headerlink" href="#asynchia.Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>All I/O is done over Transports. This enables Handlers to be written
in a generic way and used with different transports.</p>
<dl class="method">
<dt id="asynchia.Transport.handle_cleanup">
<tt class="descname">handle_cleanup</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever the Handler is voided, for whatever reason.
This may be the shutdown of the program, the closing of the
connection by the local end or the like.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_close">
<tt class="descname">handle_close</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection closed. Note that this is only called if the
connection is closed by the remote end!</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_connect">
<tt class="descname">handle_connect</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection established.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_connect_failed">
<tt class="descname">handle_connect_failed</tt><big>(</big><em>err</em><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_connect_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection couldn&#8217;t be established.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_error">
<tt class="descname">handle_error</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle error in handler.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_except">
<tt class="descname">handle_except</tt><big>(</big><em>err</em><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_except" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle exception state at error.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_read">
<tt class="descname">handle_read</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle read I/O at socket.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.handle_write">
<tt class="descname">handle_write</tt><big>(</big><big>)</big><a class="headerlink" href="#asynchia.Transport.handle_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle write I/O at socket.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.recv">
<tt class="descname">recv</tt><big>(</big><em>nbytes</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asynchia.Transport.recv" title="Permalink to this definition">¶</a></dt>
<dd><p>Override.</p>
</dd></dl>

<dl class="method">
<dt id="asynchia.Transport.send">
<tt class="descname">send</tt><big>(</big><em>string</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asynchia.Transport.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Override.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">API Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="asynchia.dsl.html"
                        title="next chapter">asynchia.dsl</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/asynchia.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="asynchia.dsl.html" title="asynchia.dsl"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="API Documentation"
             >previous</a> |</li>
        <li><a href="../index.html">asynchia v0.1.0a documentation</a> &raquo;</li>
          <li><a href="index.html" >API Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009, Florian Mayer.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.1.
    </div>
  </body>
</html>